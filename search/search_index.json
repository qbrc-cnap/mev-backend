{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the WebMEV documentation page. This will serve as the main source of information and documentation on the architecture and structure of MEV and its RESTful API.","title":"Home"},{"location":"#welcome-to-the-webmev-documentation-page","text":"This will serve as the main source of information and documentation on the architecture and structure of MEV and its RESTful API.","title":"Welcome to the WebMEV documentation page."},{"location":"api/","text":"Documentation on the API There are a couple aspects to the WevMEV REST API. We have the actual API endpoints which are used to drive analysis or a frontend visualization. Documentation of the API interaction is provided by auto-generated documentation conforming to the OpenAPI spec. Behind the API itself are the data structures and models that we use to architect the system. You will find information about these entities and their relationships in this section.","title":"Intro"},{"location":"api/#documentation-on-the-api","text":"There are a couple aspects to the WevMEV REST API. We have the actual API endpoints which are used to drive analysis or a frontend visualization. Documentation of the API interaction is provided by auto-generated documentation conforming to the OpenAPI spec. Behind the API itself are the data structures and models that we use to architect the system. You will find information about these entities and their relationships in this section.","title":"Documentation on the API"},{"location":"attributes/","text":"Attributes Attribute s could also be thought of as \"parameters\" and are a way of providing validated key-value pairs. The different types enforce various constraints on the underlying primitive type (e.g. a float bounded between [0,1] can represent a probability). Mainly, Attribute s are a way to add information to Observation or Feature instances. For example, one could specify the phenotype or experimental group of an Observation via a StringAttribute . class api.data_structures.attributes. BaseAttribute ( value , **kwargs ) Base object which defines some common methods and members for Attribute types Classes that derive from BaseAttribute have strings which identify their type ( typename ) and a value , which is specific to the child class implementation. See child classes for examples. class api.data_structures.attributes. BoundedBaseAttribute ( value , **kwargs ) This class derives from BaseAttribute and adds logic for numeric attributes that are bounded between specified values. In addition to the typename and value members, these require a min and a max to set the bounds. Classes deriving from this can be used for things like bounding a p-value from a hypothesis test (which is 0<=p<=1) class api.data_structures.attributes. IntegerAttribute ( value , **kwargs ) General, unbounded integers. Represented by { \"attribute_type\": \"Integer\", \"value\": <integer> } class api.data_structures.attributes. PositiveIntegerAttribute ( value , **kwargs ) Integers > 0 { \"attribute_type\": \"PositiveInteger\", \"value\": <integer> } class api.data_structures.attributes. NonnegativeIntegerAttribute ( value , **kwargs ) Integers >=0 { \"attribute_type\": \"NonNegativeInteger\", \"value\": <integer> } class api.data_structures.attributes. BoundedIntegerAttribute ( value , **kwargs ) Integers that are bounded between a min and max value. { \"attribute_type\": \"BoundedInteger\", \"value\": <integer>, \"min\": <integer lower bound>, \"max\": <integer upper bound> } class api.data_structures.attributes. FloatAttribute ( value , **kwargs ) General, unbounded float type { \"attribute_type\": \"Float\", \"value\": <float> } class api.data_structures.attributes. PositiveFloatAttribute ( value , **kwargs ) Positive (>0) float type { \"attribute_type\": \"PositiveFloat\", \"value\": <float> } class api.data_structures.attributes. NonnegativeFloatAttribute ( value , **kwargs ) Non-negative (>=0) float type { \"attribute_type\": \"NonNegativeFloat\", \"value\": <float> } class api.data_structures.attributes. BoundedFloatAttribute ( value , **kwargs ) Floats that are bounded between a min and max value. { \"attribute_type\": \"BoundedFloat\", \"value\": <float>, \"min\": <integer/float lower bound>, \"max\": <integer/float upper bound> } class api.data_structures.attributes. StringAttribute ( value , **kwargs ) String type that has basic guards against non-typical characters. { \"attribute_type\": \"String\", \"value\": <str> } api.data_structures.attributes. create_attribute ( attr_key , attribute_dict ) Utility function used by the serializers to create/return BaseAttribute-derived instances. Accepts an attribute_dict which is a Python dictionary object containing the keys appropriate to create a particular attribute. For example, to create a BoundedIntegerAttribute , this dict would be formatted as, attr_dict = { 'attribute_type': 'BoundedInteger', 'value': 3, 'min': 0, 'max': 10 }","title":"Attributes"},{"location":"attributes/#attributes","text":"Attribute s could also be thought of as \"parameters\" and are a way of providing validated key-value pairs. The different types enforce various constraints on the underlying primitive type (e.g. a float bounded between [0,1] can represent a probability). Mainly, Attribute s are a way to add information to Observation or Feature instances. For example, one could specify the phenotype or experimental group of an Observation via a StringAttribute . class api.data_structures.attributes. BaseAttribute ( value , **kwargs ) Base object which defines some common methods and members for Attribute types Classes that derive from BaseAttribute have strings which identify their type ( typename ) and a value , which is specific to the child class implementation. See child classes for examples. class api.data_structures.attributes. BoundedBaseAttribute ( value , **kwargs ) This class derives from BaseAttribute and adds logic for numeric attributes that are bounded between specified values. In addition to the typename and value members, these require a min and a max to set the bounds. Classes deriving from this can be used for things like bounding a p-value from a hypothesis test (which is 0<=p<=1) class api.data_structures.attributes. IntegerAttribute ( value , **kwargs ) General, unbounded integers. Represented by { \"attribute_type\": \"Integer\", \"value\": <integer> } class api.data_structures.attributes. PositiveIntegerAttribute ( value , **kwargs ) Integers > 0 { \"attribute_type\": \"PositiveInteger\", \"value\": <integer> } class api.data_structures.attributes. NonnegativeIntegerAttribute ( value , **kwargs ) Integers >=0 { \"attribute_type\": \"NonNegativeInteger\", \"value\": <integer> } class api.data_structures.attributes. BoundedIntegerAttribute ( value , **kwargs ) Integers that are bounded between a min and max value. { \"attribute_type\": \"BoundedInteger\", \"value\": <integer>, \"min\": <integer lower bound>, \"max\": <integer upper bound> } class api.data_structures.attributes. FloatAttribute ( value , **kwargs ) General, unbounded float type { \"attribute_type\": \"Float\", \"value\": <float> } class api.data_structures.attributes. PositiveFloatAttribute ( value , **kwargs ) Positive (>0) float type { \"attribute_type\": \"PositiveFloat\", \"value\": <float> } class api.data_structures.attributes. NonnegativeFloatAttribute ( value , **kwargs ) Non-negative (>=0) float type { \"attribute_type\": \"NonNegativeFloat\", \"value\": <float> } class api.data_structures.attributes. BoundedFloatAttribute ( value , **kwargs ) Floats that are bounded between a min and max value. { \"attribute_type\": \"BoundedFloat\", \"value\": <float>, \"min\": <integer/float lower bound>, \"max\": <integer/float upper bound> } class api.data_structures.attributes. StringAttribute ( value , **kwargs ) String type that has basic guards against non-typical characters. { \"attribute_type\": \"String\", \"value\": <str> } api.data_structures.attributes. create_attribute ( attr_key , attribute_dict ) Utility function used by the serializers to create/return BaseAttribute-derived instances. Accepts an attribute_dict which is a Python dictionary object containing the keys appropriate to create a particular attribute. For example, to create a BoundedIntegerAttribute , this dict would be formatted as, attr_dict = { 'attribute_type': 'BoundedInteger', 'value': 3, 'min': 0, 'max': 10 }","title":"Attributes"},{"location":"auth/","text":"Docs on authentication","title":"Authentication"},{"location":"auth/#docs-on-authentication","text":"","title":"Docs on authentication"},{"location":"elements/","text":"Elements, Observations, and Features We adopt the convention from statistical learning of referring to Observation s and Feature s of data. Both of these data structures derive from BaseElement , which captures their common structure. Specialization specific to each can be overridden in the child classes. In an experimental context, Observation s are analogous to samples. That is, each Observation has one or more Feature s associated with it (e.g. gene expressions for 30,000 genes). Collectively, we can think of Observation s and Feature s as comprising the rows and columns of a two-dimensional matrix. We use Observation s and Feature s to hold metadata about data that we manipulating in MEV. We can attach attributes to these to allow users to set experimental groups, or other information usedful for visualization or filtering. These data structures have similar (if not exactly the same) behavior but we separate them for future compatability in case specialization of each class is needed. class api.data_structures.element. BaseElement ( id , attribute_dict={} ) A BaseElement is a base class from which we can derive both Observation and Features . For the purposes of clarity, we keep those entities separate. Yet, their behavior and structure are very much the same. This also allows us to add custom behavior to each at a later time if we require. An Element is structured as: { \"id\": <string identifier>, \"attributes\": { \"keyA\": <Attribute>, \"keyB\": <Attribute> } } class api.data_structures.observation. Observation ( id , attribute_dict={} ) An Observation is the generalization of a \"sample\" in the typical context of biological studies. One may think of samples and observations as interchangeable concepts. We call it an observation so that we are not limited by this convention, however. Observation instances act as metadata and can be used to filter and subset the data to which it is associated/attached. An Observation is structured as: { \"id\": <string identifier>, \"attributes\": { \"keyA\": <Attribute>, \"keyB\": <Attribute> } } class api.data_structures.feature. Feature ( id , attribute_dict={} ) A Feature can also be referred to as a covariate or variable. These are measurements one can make about an Observation . For example, in the genomics context, a sample can have 30,000+ genes which we call \"features\" here. In the statistical learning context, these are feature vectors. Feature instances act as metadata and can be used to filter and subset the data to which it is associated/attached. For example, we can imagine filtering by genes/features which have a particular value, such as those genes where the attribute \"oncogene\" is set to \"true\" A Feature is structured as: { \"id\": <string identifier>, \"attributes\": { \"keyA\": <Attribute>, \"keyB\": <Attribute> } }","title":"Observations and Features"},{"location":"elements/#elements-observations-and-features","text":"We adopt the convention from statistical learning of referring to Observation s and Feature s of data. Both of these data structures derive from BaseElement , which captures their common structure. Specialization specific to each can be overridden in the child classes. In an experimental context, Observation s are analogous to samples. That is, each Observation has one or more Feature s associated with it (e.g. gene expressions for 30,000 genes). Collectively, we can think of Observation s and Feature s as comprising the rows and columns of a two-dimensional matrix. We use Observation s and Feature s to hold metadata about data that we manipulating in MEV. We can attach attributes to these to allow users to set experimental groups, or other information usedful for visualization or filtering. These data structures have similar (if not exactly the same) behavior but we separate them for future compatability in case specialization of each class is needed. class api.data_structures.element. BaseElement ( id , attribute_dict={} ) A BaseElement is a base class from which we can derive both Observation and Features . For the purposes of clarity, we keep those entities separate. Yet, their behavior and structure are very much the same. This also allows us to add custom behavior to each at a later time if we require. An Element is structured as: { \"id\": <string identifier>, \"attributes\": { \"keyA\": <Attribute>, \"keyB\": <Attribute> } } class api.data_structures.observation. Observation ( id , attribute_dict={} ) An Observation is the generalization of a \"sample\" in the typical context of biological studies. One may think of samples and observations as interchangeable concepts. We call it an observation so that we are not limited by this convention, however. Observation instances act as metadata and can be used to filter and subset the data to which it is associated/attached. An Observation is structured as: { \"id\": <string identifier>, \"attributes\": { \"keyA\": <Attribute>, \"keyB\": <Attribute> } } class api.data_structures.feature. Feature ( id , attribute_dict={} ) A Feature can also be referred to as a covariate or variable. These are measurements one can make about an Observation . For example, in the genomics context, a sample can have 30,000+ genes which we call \"features\" here. In the statistical learning context, these are feature vectors. Feature instances act as metadata and can be used to filter and subset the data to which it is associated/attached. For example, we can imagine filtering by genes/features which have a particular value, such as those genes where the attribute \"oncogene\" is set to \"true\" A Feature is structured as: { \"id\": <string identifier>, \"attributes\": { \"keyA\": <Attribute>, \"keyB\": <Attribute> } }","title":"Elements, Observations, and Features"},{"location":"install/","text":"Installation instructions","title":"Install"},{"location":"install/#installation-instructions","text":"","title":"Installation instructions"},{"location":"resource_types/","text":"Resource types A Resource represents some generic notion of data and its resource_type field/member is a string identifier that identifies the specific format of the data. The string identifiers map to concrete classes that implement validation methods for the Resource . When a new Resource is added (via upload or directly by an admin via the API), the validation method is called. Similarly, if a user tries to change the resource_type , it will trigger the validation process. Current resource_types fall into two broad categories: Table-based formats Sequence-based formats Table-based formats are any array-like format, such as a typical CSV file. This covers a wide variety of standard formats encountered in computational biology, including GTF annotation files and BED files. The primitive data types contained in each column are determined using Python's Pandas library, which refers to these as \"dtypes\"; for example, a column identified as int64 certainly qualifies as an integer type. If the column contains any non-integers (but all numbers), Pandas automatically converts it to a float type (e.g. float64 ) which allows us to easily validate the content of each column. Sequence-based formats are formats like FastQ, Fasta, or SAM/BAM. Table-based resource types class api.resource_types.table_types. TableResource ( ) The TableResource is the most generic form of a delimited file. Any type of data that can be represented as rows and columns. This or any of the more specific subclasses can be contained in files saved in CSV, TSV, or Excel (xls/xlsx) format. If in Excel format, the data of interest must reside in the first sheet of the workbook. Special tab-delimited files like BED or VCF files are recognized by their canonical extension (e.g. \".bed\" or \".vcf\"). class api.resource_types.table_types. Matrix ( ) A Matrix is a delimited table-based file that has only numeric types. These types can be mixed, like floats and integers class api.resource_types.table_types. IntegerMatrix ( ) An IntegerMatrix further specializes the Matrix to admit only integers. class api.resource_types.table_types. AnnotationTable ( ) An AnnotationTable is a special type of table that will be responsible for annotating samples (e.g. adding sample names and associated attributes like experimental group or other covariates). The first column will give the sample names and the remaining columns will each individually represent different covariates associated with that sample. For example, if we received the following table: sample genotype treatment A WT Y B WT N Then this table can be used to create Attribute s which can be added to the Observation s. After the annotations are uploaded, the users must tell MEV how to interpret the columns (e.g. as a string? as a bounded float?), but once that type is specified, we can validate the annotations against that choice and subsequently add the Attribute s to the Observation s. class api.resource_types.table_types. BEDFile ( ) A file format that corresponds to the BED format. This is the minimal BED format, which has: chromosome start position end position Additional columns are ignored. By default, BED files do NOT contain headers and we enforce that here. Sequence-based formats class api.resource_types.sequence_types. SequenceResource ( ) This class is used to represent sequence-based files such as Fasta, Fastq, SAM/BAM We cannot (reasonably) locally validate the contents of these files quickly or exhaustively, so minimal validation is performed remotely class api.resource_types.sequence_types. FastAResource ( ) This type is for validating Fasta files, compressed or not. Fasta files are recognized using the following formats: fasta fasta.gz fa fa.gz class api.resource_types.sequence_types. FastQResource ( ) This resource type is for Fastq files, compressed or not. Fastq files are recognized using the following formats: fastq fastq.gz fq fq.gz class api.resource_types.sequence_types. AlignedSequenceResource ( ) This resource type is for SAM/BAM files. We accept both SAM and BAM files named using their canonical extensions: \".bam\" for BAM files \".sam\" for SAM files","title":"Resource types"},{"location":"resource_types/#resource-types","text":"A Resource represents some generic notion of data and its resource_type field/member is a string identifier that identifies the specific format of the data. The string identifiers map to concrete classes that implement validation methods for the Resource . When a new Resource is added (via upload or directly by an admin via the API), the validation method is called. Similarly, if a user tries to change the resource_type , it will trigger the validation process. Current resource_types fall into two broad categories: Table-based formats Sequence-based formats Table-based formats are any array-like format, such as a typical CSV file. This covers a wide variety of standard formats encountered in computational biology, including GTF annotation files and BED files. The primitive data types contained in each column are determined using Python's Pandas library, which refers to these as \"dtypes\"; for example, a column identified as int64 certainly qualifies as an integer type. If the column contains any non-integers (but all numbers), Pandas automatically converts it to a float type (e.g. float64 ) which allows us to easily validate the content of each column. Sequence-based formats are formats like FastQ, Fasta, or SAM/BAM.","title":"Resource types"},{"location":"resource_types/#table-based-resource-types","text":"class api.resource_types.table_types. TableResource ( ) The TableResource is the most generic form of a delimited file. Any type of data that can be represented as rows and columns. This or any of the more specific subclasses can be contained in files saved in CSV, TSV, or Excel (xls/xlsx) format. If in Excel format, the data of interest must reside in the first sheet of the workbook. Special tab-delimited files like BED or VCF files are recognized by their canonical extension (e.g. \".bed\" or \".vcf\"). class api.resource_types.table_types. Matrix ( ) A Matrix is a delimited table-based file that has only numeric types. These types can be mixed, like floats and integers class api.resource_types.table_types. IntegerMatrix ( ) An IntegerMatrix further specializes the Matrix to admit only integers. class api.resource_types.table_types. AnnotationTable ( ) An AnnotationTable is a special type of table that will be responsible for annotating samples (e.g. adding sample names and associated attributes like experimental group or other covariates). The first column will give the sample names and the remaining columns will each individually represent different covariates associated with that sample. For example, if we received the following table: sample genotype treatment A WT Y B WT N Then this table can be used to create Attribute s which can be added to the Observation s. After the annotations are uploaded, the users must tell MEV how to interpret the columns (e.g. as a string? as a bounded float?), but once that type is specified, we can validate the annotations against that choice and subsequently add the Attribute s to the Observation s. class api.resource_types.table_types. BEDFile ( ) A file format that corresponds to the BED format. This is the minimal BED format, which has: chromosome start position end position Additional columns are ignored. By default, BED files do NOT contain headers and we enforce that here.","title":"Table-based resource types"},{"location":"resource_types/#sequence-based-formats","text":"class api.resource_types.sequence_types. SequenceResource ( ) This class is used to represent sequence-based files such as Fasta, Fastq, SAM/BAM We cannot (reasonably) locally validate the contents of these files quickly or exhaustively, so minimal validation is performed remotely class api.resource_types.sequence_types. FastAResource ( ) This type is for validating Fasta files, compressed or not. Fasta files are recognized using the following formats: fasta fasta.gz fa fa.gz class api.resource_types.sequence_types. FastQResource ( ) This resource type is for Fastq files, compressed or not. Fastq files are recognized using the following formats: fastq fastq.gz fq fq.gz class api.resource_types.sequence_types. AlignedSequenceResource ( ) This resource type is for SAM/BAM files. We accept both SAM and BAM files named using their canonical extensions: \".bam\" for BAM files \".sam\" for SAM files","title":"Sequence-based formats"},{"location":"resources/","text":"Resources Much of the information regarding Resource instances is provided in the auto-generated docstring below, but here we highlight some key elements of the Resource model. Namely, the kinds of operations users and admins can take to create, delete, or otherwise manipulated Resource s via the API. Resource creation Regular MEV users can only create Resource instances by uploading files, either via a direct method (upload from local machine) or by using one our cloud-based uploaders. They can't do this via the API. Admins can \"override\" and create Resource instances manually via the API. Regardless of who created the Resource , the validation process is started asynchronously. We cannot assume that the files are properly validated, even if the request was initiated by an admin. Upon creation of the Resource , it is immediately set to \"inactive\" ( is_active = False ) while we validate the particular type. Resource instances have a single owner, which is the owner who uploaded the file, or directly specified by the admin in the API request. Resource \"type\" A Resource is required to have a \"type\" (e.g. an integer matrix) which we call a resource_type . These types are restricted to a set of common file formats. Upon creation, resource_type is set to None which indicates that the Resource has not been validated. The type of the Resource can be specified when the file is uploaded or at any other time (i.e. users can change the type if they desire). Each request to change type initiates an asynchronous validation process. If the validation of the resource_type fails, we revert back to the previous successfully validated type. If the type was previously None (as with a new upload), we simply revert back to None and inform the user the validation failed. Resources and Workspaces Resource instances are initially \"unattached\" meaning they are associated with their owner, but have not been associated with any user workspaces. Admins can, however, specify a Workspace in their request to create the Resource directly via the API. When a user chooses to \"add\" a Resource to a Workspace , a new database record is created which is a copy of the original, unattached Resource with the same attributes except the unique Resource UUID. Thus, we have two database records referencing the same file. We could accomplish something similar with a many-to-one mapping of Workspace to Resource s, but this was a choice we made which could allow for resource-copying if we ever allow file-editing in the future. In that case, attaching a Resource to a Workspace could create a copy of the file such that the original Resource remains unaltered. The user can, of course, change any of the mutable members of this new Workspace -associated Resource . The changes will be independent of the original \"unattached\" Resource . Users can remove a Resource from a Workspace if it has NOT been used for any portions of the analysis. We want to retain the completeness of the analysis, so deleting files that are part of the analysis \"tree\" would create gaps. Deletion of Resources Since multiple database records can reference the same underlying file, we have a bit of custom logic for determining when we delete only the database record versus deleting the actual underlying file. Essentially, if a deletion is requested and no other Resource database records reference the same file, then we delete both the database record AND the file. In the case where there is another database record referencing that file, we only remove the database record, leaving the file. Notes related to backend implementation In general, the is_active = False flag disallows any updating of the Resource attributes via the API. All post/patch/put requests will return a 400 status. This prevents multiple requests from interfering with an ongoing background process. Users cannot change the path member. The actual storage of the files should not matter to the users so they are unable to change the path member. class api.models.resource. Resource ( *args , **kwargs ) A Resource is an abstraction of data. It represents some piece of data we are analyzing or manipulating in the course of an analysis workflow. Resource s are most often represented by flat files, but their physical storage is not important. They could be stored locally or in cloud storage accessible to MEV. Various \"types\" of Resource s implement specific constraints on the data that are important for tracking inputs and outputs of analyses. For example, if an analysis module needs to operate on a matrix of integers, we can enforce that the only Resource s available as inputs are those identified (and verified) as IntegerMatrix \"types\". Note that we store all types of Resource s in the database as a single table and maintain the notion of \"type\" by a string-field identifier. Creating specific database tables for each type of Resource would be unnecessary. By connecting the string stored in the database with a concrete implementation class we can check the type of the Resource . Resource s are not active ( is_active flag in the database) until their \"type\" has been verified. API users will submit the intended type with the request and the backend will check that. Violations are reported and the Resource remains inactive ( is_active=False ). Some additional notes: Resource s are owned by users and can be added to a Workspace . However, that is not required-- Resource s can be \"unattached\". Regular users (non-admins) can't create new Resource directly via the API. The only way they can create a Resource is indirectly by adding a new upload. When a Resource is added to a Workspace , a new copy of the database record is made. This maintains the state of the original Resource . Resource s can be made \"public\" so that others can view and import them. Once another user chooses to import the file, a copy is made and that new user has their own copy. If a Resource is later made \"private\" then any files that have been \"used\" by others cannot be recalled. Resource s can be removed from a Workspace , but only if they have not been used for any analyses/operations. Resource s cannot be transferred from one Workspace to another, but they can be copied. A change in the type of the Resource can be requested. Until the validation of that change is complete, the Resource is made private and inactive. Admins can make essentially any change to Resources , including creation. However, they must be careful to maintain the integrity of the database and the files they point to. In a request to create a Resource via the API, the resource_type field can be blank/null. The type can be inferred from the path of the resource. We can do this because only admins are allowed to create via the API and they should only generate such requests if the resource type can be inferred (i.e. admins know not to give bad requests to the API...)","title":"General info"},{"location":"resources/#resources","text":"Much of the information regarding Resource instances is provided in the auto-generated docstring below, but here we highlight some key elements of the Resource model. Namely, the kinds of operations users and admins can take to create, delete, or otherwise manipulated Resource s via the API. Resource creation Regular MEV users can only create Resource instances by uploading files, either via a direct method (upload from local machine) or by using one our cloud-based uploaders. They can't do this via the API. Admins can \"override\" and create Resource instances manually via the API. Regardless of who created the Resource , the validation process is started asynchronously. We cannot assume that the files are properly validated, even if the request was initiated by an admin. Upon creation of the Resource , it is immediately set to \"inactive\" ( is_active = False ) while we validate the particular type. Resource instances have a single owner, which is the owner who uploaded the file, or directly specified by the admin in the API request. Resource \"type\" A Resource is required to have a \"type\" (e.g. an integer matrix) which we call a resource_type . These types are restricted to a set of common file formats. Upon creation, resource_type is set to None which indicates that the Resource has not been validated. The type of the Resource can be specified when the file is uploaded or at any other time (i.e. users can change the type if they desire). Each request to change type initiates an asynchronous validation process. If the validation of the resource_type fails, we revert back to the previous successfully validated type. If the type was previously None (as with a new upload), we simply revert back to None and inform the user the validation failed. Resources and Workspaces Resource instances are initially \"unattached\" meaning they are associated with their owner, but have not been associated with any user workspaces. Admins can, however, specify a Workspace in their request to create the Resource directly via the API. When a user chooses to \"add\" a Resource to a Workspace , a new database record is created which is a copy of the original, unattached Resource with the same attributes except the unique Resource UUID. Thus, we have two database records referencing the same file. We could accomplish something similar with a many-to-one mapping of Workspace to Resource s, but this was a choice we made which could allow for resource-copying if we ever allow file-editing in the future. In that case, attaching a Resource to a Workspace could create a copy of the file such that the original Resource remains unaltered. The user can, of course, change any of the mutable members of this new Workspace -associated Resource . The changes will be independent of the original \"unattached\" Resource . Users can remove a Resource from a Workspace if it has NOT been used for any portions of the analysis. We want to retain the completeness of the analysis, so deleting files that are part of the analysis \"tree\" would create gaps. Deletion of Resources Since multiple database records can reference the same underlying file, we have a bit of custom logic for determining when we delete only the database record versus deleting the actual underlying file. Essentially, if a deletion is requested and no other Resource database records reference the same file, then we delete both the database record AND the file. In the case where there is another database record referencing that file, we only remove the database record, leaving the file. Notes related to backend implementation In general, the is_active = False flag disallows any updating of the Resource attributes via the API. All post/patch/put requests will return a 400 status. This prevents multiple requests from interfering with an ongoing background process. Users cannot change the path member. The actual storage of the files should not matter to the users so they are unable to change the path member. class api.models.resource. Resource ( *args , **kwargs ) A Resource is an abstraction of data. It represents some piece of data we are analyzing or manipulating in the course of an analysis workflow. Resource s are most often represented by flat files, but their physical storage is not important. They could be stored locally or in cloud storage accessible to MEV. Various \"types\" of Resource s implement specific constraints on the data that are important for tracking inputs and outputs of analyses. For example, if an analysis module needs to operate on a matrix of integers, we can enforce that the only Resource s available as inputs are those identified (and verified) as IntegerMatrix \"types\". Note that we store all types of Resource s in the database as a single table and maintain the notion of \"type\" by a string-field identifier. Creating specific database tables for each type of Resource would be unnecessary. By connecting the string stored in the database with a concrete implementation class we can check the type of the Resource . Resource s are not active ( is_active flag in the database) until their \"type\" has been verified. API users will submit the intended type with the request and the backend will check that. Violations are reported and the Resource remains inactive ( is_active=False ). Some additional notes: Resource s are owned by users and can be added to a Workspace . However, that is not required-- Resource s can be \"unattached\". Regular users (non-admins) can't create new Resource directly via the API. The only way they can create a Resource is indirectly by adding a new upload. When a Resource is added to a Workspace , a new copy of the database record is made. This maintains the state of the original Resource . Resource s can be made \"public\" so that others can view and import them. Once another user chooses to import the file, a copy is made and that new user has their own copy. If a Resource is later made \"private\" then any files that have been \"used\" by others cannot be recalled. Resource s can be removed from a Workspace , but only if they have not been used for any analyses/operations. Resource s cannot be transferred from one Workspace to another, but they can be copied. A change in the type of the Resource can be requested. Until the validation of that change is complete, the Resource is made private and inactive. Admins can make essentially any change to Resources , including creation. However, they must be careful to maintain the integrity of the database and the files they point to. In a request to create a Resource via the API, the resource_type field can be blank/null. The type can be inferred from the path of the resource. We can do this because only admins are allowed to create via the API and they should only generate such requests if the resource type can be inferred (i.e. admins know not to give bad requests to the API...)","title":"Resources"},{"location":"workspaces/","text":"Workspaces class api.models.workspace. Workspace ( *args , **kwargs ) A Workspace is a way to logically group the files and and analyses that are part of a user's work. Users can have multiple Workspace s to separate distinct analyses. Data, files, and analyses are grouped under a Workspace such that all information related to the analyses, including analysis history, is captured the Workspace .","title":"Workspaces"},{"location":"workspaces/#workspaces","text":"class api.models.workspace. Workspace ( *args , **kwargs ) A Workspace is a way to logically group the files and and analyses that are part of a user's work. Users can have multiple Workspace s to separate distinct analyses. Data, files, and analyses are grouped under a Workspace such that all information related to the analyses, including analysis history, is captured the Workspace .","title":"Workspaces"}]}